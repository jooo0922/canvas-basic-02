'use strict';

// 라디안 값을 계산해주는 유틸리티 함수
// 좀 어려워보일 수 있으니까 변수, 함수, 파라미터명을 한글로 써보자. js는 한글로 쓸 수 있음.
function 라디안(각도){
  // 참고로 js에서 파이값은 Math.PI로 써주면 됨.
  return 각도 * Math.PI / 180;
}

const canvas = document.querySelector('.canvas');
const context = canvas.getContext('2d');

// beginPath
// 얘는 패스를 한 개만 그리더라도 버릇처럼 해줘야 함 
context.beginPath();

// arc
// 원은 따로 circle 이런 원 그리기 메소드가 따로 있는 것이 아니라, arc() 즉, '호 그리기' 메소드를 이용함.
// 호를 360도로 돌리면 원이 되니까, 우리가 하려는 거는 0부터 360도까지 호를 그린다고 보면 됨.
// 디자인이 동그란 오브젝트를 쓸 일이 많다보니 원그리기는 생각보다 많이 함.

// 넣어줘야 할 parameter가 좀 많음. 
// (x, y, 반지름, 시작 각도, 끝 각도(호를 그리는 것이기 때문에, 몇 도를 그릴것인지를 이렇게 정해줌.), boolean)
// boolean은 시작 각도부터 끝 각도까지 그릴 때 시계방향(false)/반시계방향(true)으로 그릴지를 정해주는 거.
// 원을 그릴때는 방향이 상관없으니 값을 안넣어줘도 되고 true/false를 넣어줘도 됨.

// 얘도 일단 x, y 포지션 잡는 게 먼저지만, 도형의 왼쪽 위가 기준이 아닌, '호의 중심점' 이 포지션의 기준이 됨.
// 캔버스의 가운데에 그리고 싶다면 x = width/2, y = height/2 값으로 parameter를 넣어줄 것.
// 또 우리가 0도부터 360도의 호를 그려야하는데, 360은 그냥 쓰면 안되고, 라디안 값으로 써줘야 함...
/**
 * 라디안(radian)
 * 호의 길이가 반지름과 같게 되는 만큼의 각을 1 라디안(radian)이라고 정의함.
 * 1라디안은 약 57.3도
 * 
 * 360도에 해당하는 라디안 값은 2𝝅와 같음.
 * 1도에 해당하는 라디안 값은 𝝅/180 (당연하지, 360/360 = 1 이니까, 2𝝅/360 = 𝝅/180 이 되겠지.)
 * 그러면 30도의 라디안값은 어떻게 계산할까? 당연히 𝝅/180 * 30 하면 되겠지. 
 * 
 * 이런식으로 계산하는 유틸리티 함수를 맨 위에 먼저 만들어보자.
 * 왜냐면 우리는 계산할 때는 360도 개념이 편하니까. 복잡한 라디안값을 컨트롤하기는 너무 어렵잖아
 */
// 이렇게 유틸리티 함수를 만들어놓고 쓰면, 내가 원하는 각도를 라디안값으로 알아서 계산해서 parameter로 전달해주겠죠!
context.arc(300, 200, 50, 0, 라디안(360), false); 
// 얘도 아직 원은 만들었지만 그리지는 않은 것.
// 이 상태에서 선을 그릴거면 stroke(), 색을 채울거면 fill()로 가야 함.
context.stroke();

context.beginPath();
context.arc(500, 100, 20, 0, 라디안(360), false); 
// 자 여기서 원을 하나 더 그렸는데 멋대로 직선 하나가 막 그어지게 된다.
// 이게 beginPath(), closePath()를 안해줘서 이렇게 되는거임. 
// 마치 그림을 그릴 때 붓을 종이에서 떼지 않고 그대로 다른 원을 그리러가는 것과 마찬가지임.
// beginPath()를 해줘서 시작을 명확하게 하면, 그 전에 패스가 자동으로 닫히게 하거나, closePath()를 해주거나 둘 중 하나는 해줘야 함.
// 그래서 어떤 패스 하나 그릴 때는 반드시 beginPath()를 습관적으로 선언해줘야 함.
// 지금 정리해보면 beginPath로 시작하고, arc로 원 그리고, stroke으로 선 그은 것. 여기까지가 하나 끝난 것!
// 이후에 원 하나 더 그리려면 새로운 패스 다시 시작 beginPath -> arc -> stroke 이렇게 된 것.
// beginPath를 새로 시작할 때 빠짐없이 잘 해주면 closePath()는 굳이 안해줘도 됨.
context.stroke();

// closePath

// 여기까지가 그리기 api임. 이걸로 베지어 곡선같은 복잡한 곡선도 그릴 수 있음.
// 베지어 곡선은 주로 어떨 때 쓰냐면, 특정 경로를 따라서 오브젝트를 보낸다거나 할 때 패스를 만들어서 그걸 이용해서 보내거나
// 물결, 웨이브 치는 걸 만들 때 필요함. 근데 어쩃든 사용방법이나 계산이 복잡해질 뿐이지 어차피 기본원리는 똑같음.

// 참고로 베지어 곡선은 곡선의 시작점, 끝점, 두 점의 조정점의 위치를 parameter로 넘겨주면 계산되서 알아서 베지어곡선이 나옴.
// 그래서 이 조정점을 애니메이션되게 움직이면 곡선 자체가 꾸물렁꾸물렁 움직이는 역할을 함.

// 참고로 arc는 '호'를 그리는거지 '피자 조각 모양'처럼 나오도록 그리는 게 아님.
// 그걸 만드려면 호의 양 끝점을 중심점과 연결하는 직선 2개를 추가로 그려줘야 하는거고, arc는 곡선, 원의 일부분만 그려주는 거
// 이거를 그리려면 호의 양끝점의 좌표를 알아야 함. 이런 식으로 캔버스에는 뭔가 수학같은 게 많이 들어감.

// 이처럼 캔버스의 그리기 기능은 굉장히 '저수준'임. 자동으로 되는 게 아니고 내가 일일이 해야하는 게 엄청 많음
// 그래서 캔버스로 복잡한 그림을 그려야한다고 할때 직접 그리는 경우는 거의 없고, 라이브러리를 많이 씀.
// d3.js 같은거 등등... 직접 하려면 생산성이 너무 떨어지니까ㅋㅋ

// 반대로 그렇기 때문에 할 수 있는 게 많음.
